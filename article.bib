%% LaTeX2e file `article.bib'
%% generated by the `filecontents' environment
%% from source `article' on 2023/11/05.
%%

@misc{A2012,
  author = {Buthor, B.},
  year = {2012},
  title = {Systems biology and personalized medicine are two emerging research areas, which promise to transform our health system.},
  note = {This second source is also really interesting because it contains words}
}
@article{article,
author = {Domaine, and Brandner, Florian and Boissinot, Benoit and Darte, Alain and Dinechin, Benoît and Rastello, Fabrice},
year = {2011},
month = {04},
pages = {},
title = {Computing Liveness Sets for SSA-Form Programs}
}
@article{linear,
volume = {21},
year = {1999},
abstract = {We describe a new algorithm for fast global register allocation called linear scan . This algorithm is not based on graph coloring, but allocates registers to variables in a single linear-time scan of the variables' live ranges. The linear scan algorithm is considerably faster than algorithms based on graph coloring, is simple to implement, and results in code that is almost as efficient as that obtained using more complex and time-consuming register allocators based on graph coloring. The algorithm is of interest in applications where compile time is a concern, such as dynamic compilation systems, "just-in-time" compilers, and interactive development environments.},
author = {Poletto, Massimiliano and Sarkar, Vivek},
issn = {0164-0925},
journal = {ACM transactions on programming languages and systems},
keywords = {Algorithms ; Code generation ; Code generators ; Code optimization ; Compilers ; Design and construction ; Linear systems ; Optimazation ; Processors - compilers ; Register allocation},
language = {eng},
number = {5},
pages = {895-913},
publisher = {ACM},
title = {Linear scan register allocation},
copyright = {Copyright 2018 Elsevier B.V., All rights reserved.},
}


@Online{AM1,
    accessed = {2023-11-05},
    author   = {LLVM},
    title    = {\texttt{llvm-project/AArch64TargetParser.def · llvm/lvm-project · GitHub}},
    url = {https://web.archive.org/web/20220504192056/https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/Support/AArch64TargetParser.def}
}

@book{tiger,
publisher = {Cambridge University Press},
title = {Modern Compiler Implementation in ML},
year = {1997},
abstract = {This new, expanded textbook describes all phases of a modern compiler: lexical analysis, parsing, abstract syntax, semantic actions, intermediate representations, instruction selection via tree matching, dataflow analysis, graph-coloring register allocation, and runtime systems. It includes good coverage of current techniques in code generation and register allocation, as well as functional and object-oriented languages, that are missing from most books. In addition, more advanced chapters are now included so that it can be used as the basis for two-semester or graduate course. The most accepted and successful techniques are described in a concise way, rather than as an exhaustive catalog of every possible variant. Detailed descriptions of the interfaces between modules of a compiler are illustrated with actual C header files. The first part of the book, Fundamentals of Compilation, is suitable for a one-semester first course in compiler design. The second part, Advanced Topics, which includes the advanced chapters, covers the compilation of object-oriented and functional languages, garbage collection, loop optimizations, SSA form, loop scheduling, and optimization for cache-memory hierarchies.},
author = {Appel, Andrew W.},
copyright = {Andrew W. Appel 1998},
isbn = {0521582741},
keywords = {Compilers (Computer programs) ; ML (Computer program language)},
language = {eng},
}


@book{dragon,
publisher = {Pearson Education Limited},
title = {Compilers : principles, techniques, and tools },
year = {2014},
author = {Aho, Alfred V. and lan, Monica S. and Sethi, Ravi and Ullmann, Jeffrey D.},
address = {Harlow},
booktitle = {Compilers : principles, techniques, and tools},
edition = {2nd ed., internat. ed.},
isbn = {1292024348},
keywords = {Compiler},
language = {eng},
}

@article{ShiYunhe2008VmsS,
publisher = {ACM},
title = {Virtual machine showdown: Stack versus registers},
volume = {4},
year = {2008},
abstract = {Virtual machines (VMs) enable the distribution of programs in an architecture-neutral format, which can easily be interpreted or compiled. A long-running question in the design of VMs is whether a stack architecture or register architecture can be implemented more efficiently with an interpreter. We extend existing work on comparing virtual stack and virtual register architectures in three ways. First, our translation from stack to register code and optimization are much more sophisticated. The result is that we eliminate an average of more than 46\% of executed VM instructions, with the bytecode size of the register machine being only 26\% larger than that of the corresponding stack one. Second, we present a fully functional virtual-register implementation of the Java virtual machine (JVM), which supports Intel, AMD64, PowerPC and Alpha processors. This register VM supports inline-threaded, direct-threaded, token-threaded, and switch dispatch. Third, we present experimental results on a range of additional optimizations such as register allocation and elimination of redundant heap loads. On the AMD64 architecture the register machine using switch dispatch achieves an average speedup of 1.48 over the corresponding stack machine. Even using the more efficient inline-threaded dispatch, the register VM achieves a speedup of 1.15 over the equivalent stack-based VM.},
author = {Shi, Yunhe and Casey, Kevin and Ertl, M and Gregg, David},
copyright = {Copyright 2017 Elsevier B.V., All rights reserved.},
issn = {1544-3566},
journal = {ACM transactions on architecture and code optimization},
keywords = {Interpreter ; Language ; Register architecture ; Stack architecture ; Virtual machine},
language = {eng},
number = {4},
pages = {1-36},
}

@online{dotnet,
  author = {Martin Woodward, Executive Director, .NET Foundation},
  title = {Announcing LLILC - A new LLVM-based Compiler for .NET},
  year = 2015,
  url = {https://web.archive.org/web/20211212184833/https://dotnetfoundation.org/blog/2015/04/14/announcing-llilc-llvm-for-dotnet},
  urldate = {2020-09-12}
}

@online{clang,
  author = {LLVM Foundation}, 
  title = {Clang: a C language family frontend for LLVM},
  url = {https://web.archive.org/web/20231230181618/https://clang.llvm.org/},
  urldate = {2023-12-30}
}

@online{dlang,
  author = {D Language Foundation}, 
  title = {LDC – the LLVM-based D Compiler},
  url = {https://web.archive.org/web/20231230181935/https://github.com/ldc-developers/ldc},
  urldate = {2023-12-30}
}

@online{swift,
  author = {Apple Inc.}, 
  title = {LDC – the LLVM-based D Compiler},
  url = {https://web.archive.org/web/20231230182842/https://developer.apple.com/swift/},
  urldate = {2023-12-30}
}

@online{rustc,
  author = {Apple Inc.}, 
  title = {LDC – the LLVM-based D Compiler},
  url = {https://web.archive.org/web/20231230185321/https://rustc-dev-guide.rust-lang.org/overview.html},
  urldate = {2023-12-30}
}

@online{kotlin,
  author = {Kotlin Foundation}, 
  title = {Kotlin Native},
  url = {https://web.archive.org/web/20231230192142/https://kotlinlang.org/docs/native-overview.html},
  urldate = {2023-12-30}
}

@online{backend,
  author = {LLVM Foundation}, 
  title = {Writing an LLVM Backend},
  url = {https://web.archive.org/web/20231230200453/https://llvm.org/docs/WritingAnLLVMBackend.html},
  urldate = {2023-12-30}
}

@online{latency,
  author = {Jeff Dean and Peter Norvig},
  title = {Latency Comparison Numbers},
  url = {https://web.archive.org/web/20240101182413/https://gist.github.com/jboner/2841832},
  urldate = {2024-01-01}
}

@online{pdp90amanual,
author = {Thorlabs},
title = {PDP90A Position Sensing Detector User Guide},
date = {2015-11-6},
language = {English},
version = {},
organization = {Thorlabs},
pagetotal = {12},
pubstate = {forthcoming},
}

@manual{sysv,
  title = {System V Application Binary Interface AMD64 Architecture Processor Supplement (With LP64 and ILP32 Programming Models) Version 1.0}},
  author = {H.J. Lu, Michael Matz, Milind Girkar, Jan Hubicka, Andreas Jaeger, Mark Mitchell},
  date = {2015-11-6},
  version = {1.0}
}
@footnote{sysv-variadic,
  title = {Title of the Source Document},
  author = {Author Name},
  year = {Year},
  note = {Page Number or Context of the Footnote}
}

@online{ocamlgraph,
  title = {OCamlgraph},
  authors = {Sylvain Conchon, Jean-Christophe Filliâtre, François Pottier, Julien Signoles, Vincent Simonet, Matthieu Sozeau},
  url = {https://github.com/backtracking/ocamlgraph},
  date = {2024-01-02}
}

@online{x86asm,
  title = {X86 Opcode and Instruction Reference 1.12},
  authors = {Karel Lejska},
  url = {https://web.archive.org/web/20240104142515/http://ref.x86asm.net/geek64-abc.html#M},
  date = {2024-01-04}
}

@inproceedings{chaitin,
abstract = {In a previous paper we reported the successful use of graph coloring techniques for doing global register allocation in an experimental PL/I optimizing compiler. When the compiler cannot color the register conflict graph with a number of colors equal to the number of available machine registers, it must add code to spill and reload registers to and from storage. Previously the compiler produced spill code whose quality sometimes left much to be desired, and the ad hoe techniques used took considerable amounts of compile time. We have now discovered how to extend the graph coloring approach so that it naturally solves the spilling problem. Spill decisions are now made on the basis of the register conflict graph and cost estimates of the value of keeping the result of a computation in a register rather than in storage. This new approach produces better object code and takes much less compile time.},
author = {Chaitin, G},
booktitle = {Proceedings of the 1982 SIGPLAN symposium on compiler construction},
isbn = {9780897910743},
language = {eng},
pages = {98-105},
publisher = {ACM},
title = {Register allocation \& spilling via graph coloring},
year = {1982},
}


@online{llvm-functions, 
  title = {LLVM Language Reference Manual - Functions},
  url = {https://releases.llvm.org/9.0.0/docs/LangRef.html#functions},
  date = {2024-01-13}
}

@online{sha256, 
  title = {Fast SHA-2 hashes in x86 assembly},
  url={https://www.nayuki.io/page/fast-sha2-hashes-in-x86-assembly},
}

@online{fannkuch,
  title ={fannkuch-redux C gcc #5 program},
  author = {Jeremy Zerfas},
  url = {https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/fannkuchredux-gcc-5.html},
}

@online{cstd, 
  url = {https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Structures},
  title = {The GNU C Reference Manual: Structures}
}

@online{landmarks, 
  url = {https://github.com/LexiFi/landmarks},
title = {Landmarks: A Simple Profiling Library}
}


@book{BrandnerFlorian2011CLSf,
abstract = {We revisit the problem of computing liveness sets, i.e., the set of variables live-in and live-out of basic blocks, for programs in strict SSA (static single assignment). Strict SSA is also known as SSA with dominance property because it ensures that the definition of a variable always dominates all its uses. This property can be exploited to optimize the computation of liveness sets. Our first contribution is the design of a fast data-flow algorithm, which, unlike traditional approaches, avoids the iterative calculation of a fixed point. Thanks to the properties of strict SSA form and the use of a loop-nesting forest, we show that two passes are sufficient. A first pass, similar to the initialization of iterative data-flow analysis, traverses the control-flow graph in postorder propagating liveness information backwards. A second pass then traverses the loop-nesting forest, updating liveness information within loops. Another approach is to propagate from uses to definition, one variable and one path at a time, instead of unioning sets as in standard data-flow analysis. Such a path-exploration strategy was proposed by Appel in his ''Tiger book'' and is also used in the LLVM compiler. Our second contribution is to show how to extend and optimize algorithms based on this idea to compute liveness sets one variable at a time using adequate data~structures. Finally, we evaluate and compare the efficiency of the proposed algorithms using the SPECINT 2000 benchmark suite. The standard data-flow approach is clearly outperformed, all algorithms show substantial speed-ups of a factor of 2 on average. Depending on the underlying set implementation either the path-exploration approach or the loop-forest-based approach provides superior performance. Experiments show that our loop-forest-based algorithm provides superior performances (average speed-up of 43% on the fastest alternative) when sets are represented as bitsets and for optimized programs, i.e., when there are more variables and larger live-sets and live-ranges.
Nous réexaminons le problème du calcul des ensembles de vivacité, c'est-à-dire des ensembles de variables en vie en entrée et sortie des blocs de base d'un programme en forme SSA (assignation unique statique) stricte. La forme SSA stricte est également appelée SSA avec propriété de dominance parce qu'elle garantit que la définition d'une variable domine toujours toutes ses utilisations. Nous exploitons cette propriété pour optimiser le calcul de vivacité. Notre première contribution est la conception d'un algorithme rapide de type flot de données qui, à la différence des approches traditionnelles, évite les itérations de calcul de point fixe. Grâce aux propriétés de la forme SSA stricte et à l'utilisation d'une hiérarchie de boucles (''loop-nesting forest''), nous montrons que deux passes sont suffisantes. Une première passe, similaire à la phase d'initialisation de la méthode de flot de données itérative, propage les informations de vivacité en remontant un parcours en profondeur du graphe de flot de contrôle. Une deuxième passe parcourt la hiérarchie de boucles pour mettre à jour l'information dans les boucles. Une autre approche consiste à propager depuis les utilisations jusqu'à la définition, une variable et un chemin à la fois, plutôt que d'effectuer des unions d'ensembles comme dans l'analyse de flot de données standard. Une telle stratégie d'exploration des chemins a été proposée par Appel dans son ''Tiger book'' et est également utilisée dans le compilateur LLVM. Notre seconde contribution est de montrer comment étendre et optimiser un algorithme basé sur cette idée pour calculer les ensembles de vivacité, une variable à la fois, et avec des structures de données adéquates. Finalement, nous évaluons et comparons les performances des algorithmes proposés avec les ''benchmarks'' de SPECINT 2000. L'approche traditionnelle de flot de données est clairement surpassée par les autres algorithmes, avec un facteur d'amélioration de 2 en moyenne. Selon l'implantation des ensembles de vivacité, la meilleure approche est soit celle par remontée de chemin, soit celle utilisant la hiérarchie de boucles. Les expérimentations montrent que notre algorithme flot de données offre de meilleures performances (amélioration de 43% par rapport à la meilleure alternative) quant les ensembles sont représentés par des ''bitsets'' et pour les programmes optimisés, programmes avec plus de variables, et des ensembles de vivacité et des intervalles de vie plus grands.},
author = {Brandner, Florian and Boissinot, Benoit and Darte, Alain and Dupont de Dinechin, Benoît and Rastello, Fabrice},
copyright = {Distributed under a Creative Commons Attribution 4.0 International License},
keywords = {Computer Science ; Programming Languages},
language = {eng},
title = {Computing Liveness Sets for SSA-Form Programs},
year = {2011},
}

